# 架构

### 1. Broker
> 消息队列服务器，负责消息的存储、转发、查询。

每个 Broker 节点和所有 NameServer 节点保持长连接和心跳，并会定时将 Topic 信息注册到 NameServer，


### 2. NameServer
> 注册中心，主要有两个功能：**Broker 管理** 和 **路由信息管理**。

#### 2.1 特性
类似于 ZooKeeper，但是比 ZK 更轻量。主要是因为 NameServer 被设计成几乎无状态的，每个 NameServer 节点互相之间是独立的，没有任何信息交互。因此可以横向扩展，通过部署多台机器来标记自己是一个伪集群。

#### 2.2 使用
- Broker 会将自己的信息注册到 NameServer 中，NameServer 会存放所有 Broker 的信息（Broker 的路由表）；
- Consumer 和 Producer 就从 NameServer 中获取路由表然后照着路由表的信息和对应的 Broker 进行通信（Consumer 和 Producer 会定时向 NameServer 去查询相关的 Broker 的信息）。

NameServer 压力不会太大，平时主要开销是在维持心跳和提供 Topic-Broker 的关系数据。但有一点需要注意，Broker 向 NameServer 发心跳时，会带上当前自己所负责的所有 Topic 信息，如果 Topic 个数太多（万级别）会导致一次心跳中光 Topic 的数据就 10M+，网络情况差导致传输失败、心跳失败，让 NameServer 误认为 Broker 失联。


### 3. Producer
> 消息生产者

#### 3.1 消息发送方式
- 同步发送 ：发送方发出数据后，在接收方返回响应之后才发下一个数据。一般用于重要消息。
- 异步发送 ：发送方发出数据后，不等接收方返回响应，接着发送下一个数据包。一般用于可能链路耗时较长而对响应时间敏感的业务场景。
- 单向发送 ：发送方只负责发送消息，不等待接收方响应且没有回调函数触发。适用于某些耗时非常短但对可靠性要求并不高的场景，例如：日志收集。


### 4. Consumer
> 消息消费者

- 支持 push、pull 两种模式对消息进行消费；
- 也支持集群方式和广播方式的消费。


#### 4.1 消费模式
- **Pull** ：拉取型消费者主动从 Broker 拉取消息，只要批量拉取到消息，用户应用就会启动消费过程。
- **Push** ：推送型消费者封装了消息的拉取、消费进度和其他内部维护工作，将消息到达时执行的回调接口留给用户程序来实现。所以 Push 称为被动消费类型，但从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器触发后才开始消费消息。

#### 4.2 消息消费模式
- **集群消费** ：默认。一个消费者组共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其他消费者会接替挂掉的消费者继续消费。
- **广播消费** ：广播消费消息会发给消费者组中的每一个消费者进行消费。