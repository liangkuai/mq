# 问题


### 1. 顺序消费
RocketMQ 的消息在整个 Topic 中是无序的，只有具体到某个队列中才是有序的。

顺序消费又分为，
- 普通顺序
- 严格顺序

#### 普通顺序
也就是消费同一个队列是有序的。

#### 严格有序
严格顺序是指消费者收到的所有消息都是有顺序的。严格顺序消息即使在异常情况下也会保证消息的顺序性。

但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果使用严格顺序模式，Broker 集群中只要有一台机器不可用，则整个集群都不可用。现在主要场景也就在 binlog 同步。

#### 问题
Producer 生产消息时会轮询向一个 Topic 的不同队列发送消息，如果同一个订单的创建、支付、发货三个消息会被发送到不同的队列，这样队列有序没法满足消息有序了。

解决：可以按订单号 Hash 取模，发送到同一个队列中。


---
### 2. 如何避免重复消费？

#### 2.1 消息重复
消息领域有一个对消息投递的 QoS（服务质量）定义，分为：
- 最多一次（At most once）
- 至少一次（At least once）
- 仅一次（Exactly once）

几乎所有的 MQ 产品都声称自己做到了 `At least once`。

**既然是至少一次，那避免不了消息重复**，尤其是在分布式网络环境下。比如：网络波动，ACK 返回失败等等故障，确认信息没有传送到消息队列，导致消息队列不知道该消息已经消费过了，再次将该消息分发给其他的消费者。

不同的消息队列发送的确认信息形式不同，例如：
- RabbitMQ 是发送一个 ACK 确认消息，
- RocketMQ 是返回一个 `CONSUME_SUCCESS` 成功标志，
- Kafka 实际上有个 offset 的概念。

#### 2.2 消息去重
> 消息去重的方法：业务端保证幂等性。

保证每条消息有一个唯一标识，

- 弱校验 ：分布式锁
- 强校验 ：消息记录表



---
### 3. 消息堆积

产生消息堆积的根本问题只有两个，
- 生产者生产太快
- 消费者消费太慢

#### 生产太快
限流降级

#### 消费太慢
1. 排查消费是不是出问题了。
2. 最快速解决消息堆积问题的方法还是增加消费者实例，不过同时还需要增加每个主题的队列数量。（但是一个队列只会被一个消费者消费）




---
### 4. 分布式事务